---
layout: page
title: ファイルダウンロード
permalink: /download.html
hide_title: true
---

<script src="/Drowse-Lab/assets/js/ai-enhance.js"></script>
<style>
    .download-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 40px 20px;
    }

    .download-header {
        text-align: center;
        margin-bottom: 40px;
    }

    .download-header h1 {
        color: #333;
        margin-bottom: 10px;
    }

    .download-header p {
        color: #666;
    }

    .download-form {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 30px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .form-group {
        margin-bottom: 20px;
    }

    .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #333;
    }

    .form-group input {
        width: 100%;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        transition: border-color 0.3s;
    }

    .form-group input:focus {
        outline: none;
        border-color: #4CAF50;
        box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.1);
    }

    .download-button {
        width: 100%;
        padding: 14px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.3s;
    }

    .download-button:hover {
        background: #45a049;
    }

    .download-button:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    .status-message {
        margin-top: 20px;
        padding: 12px;
        border-radius: 4px;
        display: none;
    }

    .status-message.success {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
    }

    .status-message.error {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
    }

    .status-message.info {
        background: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
    }

    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #4CAF50;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-left: 10px;
        vertical-align: middle;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }


    .instructions {
        background: #f8f9fa;
        border-left: 4px solid #4CAF50;
        padding: 15px;
        margin-bottom: 20px;
    }

    .instructions h3 {
        margin-top: 0;
        color: #333;
    }

    .instructions ul {
        margin: 10px 0;
        padding-left: 20px;
    }

    .instructions li {
        margin-bottom: 5px;
        color: #666;
    }

    .checkbox-label {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-weight: 500;
    }

    .checkbox-label input[type="checkbox"] {
        width: auto;
        margin-right: 8px;
        cursor: pointer;
    }

    .quality-info {
        margin-top: 8px;
        font-size: 12px;
        color: #666;
        padding-left: 24px;
    }
    /* 戻るボタン */
    .back-button {
        display: inline-block;
        margin-bottom: 20px;
        padding: 8px 16px;
        background-color: #666;
        color: white;
        text-decoration: none;
        border-radius: 3px;
        transition: background-color 0.3s;
    }

    .back-button:hover {
        background-color: #555;
    }
</style>

<div class="download-container">
    <a href="/Drowse-Lab/other.html" class="back-button" data-i18n="download.back">← 戻る</a>
    
    <div class="download-header">
        <h1 data-i18n="download.title">ファイルダウンロード</h1>
        <p data-i18n="download.subtitle">URLからファイルをダウンロードします</p>
    </div>

    <div class="instructions">
        <h3 data-i18n="download.howToUse">使い方</h3>
        <ul>
            <li data-i18n="download.instruction1">ダウンロードしたいファイルのURLを入力してください</li>
            <li data-i18n="download.instruction2">ファイル名を指定できます（省略可）</li>
            <li data-i18n="download.instruction3">ダウンロードボタンをクリックしてファイルを保存します</li>
        </ul>
        <p style="margin-top: 15px; font-size: 13px; color: #666;">
            <strong data-i18n="download.tip">ヒント:</strong>
            <span data-i18n="download.tipContent">Fandom Wikiの画像は、画像を右クリックして「画像アドレスをコピー」で直接URLを取得するか、WikiページのURLをそのまま入力してください。</span>
        </p>
    </div>

    <div class="download-form">
        <div class="form-group">
            <label for="urlInput" data-i18n="download.urlLabel">ファイルURL</label>
            <input 
                type="url" 
                id="urlInput" 
                placeholder="https://example.com/file.pdf" 
                data-i18n-placeholder="download.urlPlaceholder"
                required
            >
        </div>

        <div class="form-group">
            <label for="filenameInput" data-i18n="download.filenameLabel">保存ファイル名（オプション）</label>
            <input 
                type="text" 
                id="filenameInput" 
                placeholder="file.pdf" 
                data-i18n-placeholder="download.filenamePlaceholder"
                list="extensionList"
            >
            <datalist id="extensionList">
                <option value=".jpg">
                <option value=".jpeg">
                <option value=".png">
                <option value=".gif">
                <option value=".webp">
                <option value=".bmp">
                <option value=".svg">
                <option value=".pdf">
                <option value=".txt">
                <option value=".html">
                <option value=".mp4">
                <option value=".mp3">
                <option value=".wav">
                <option value=".zip">
                <option value=".rar">
            </datalist>
        </div>

        <div class="form-group">
            <label class="checkbox-label">
                <input type="checkbox" id="enhanceQuality">
                <span data-i18n="download.enhanceQuality">画質を向上させる（画像のみ）</span>
            </label>
            <div class="quality-info" data-i18n="download.qualityInfo">
                画像をアップスケーリングして画質を改善します
            </div>
            <div id="resolutionOptions" style="display: none; margin-top: 15px;">
                <label for="resolutionSelect" style="display: block; margin-bottom: 8px; font-weight: 500;" data-i18n="download.resolution">解像度を選択:</label>
                <select id="resolutionSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="auto" data-i18n="download.resAuto">自動（最適な解像度）</option>
                    <option value="4k" data-i18n="download.res4k">4K (3840×2160)</option>
                    <option value="1440p" data-i18n="download.res1440p">1440p (2560×1440)</option>
                    <option value="1080p" data-i18n="download.res1080p">1080p (1920×1080)</option>
                    <option value="720p" data-i18n="download.res720p">720p (1280×720)</option>
                    <option value="original" data-i18n="download.resOriginal">オリジナルサイズ（画質向上のみ）</option>
                </select>
            </div>
        </div>
        
        <!-- YouTube用オプション -->
        <div id="youtubeOptions" style="display: none;">
            <div class="form-group">
                <label for="formatSelect" style="display: block; margin-bottom: 8px; font-weight: 600;" data-i18n="download.format">フォーマット:</label>
                <select id="formatSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="video" data-i18n="download.formatVideo">動画 (MP4)</option>
                    <option value="audio" data-i18n="download.formatAudio">音声のみ (MP3)</option>
                </select>
            </div>
            <div class="form-group" id="videoQualityGroup">
                <label for="videoQuality" style="display: block; margin-bottom: 8px; font-weight: 600;" data-i18n="download.videoQuality">動画品質:</label>
                <select id="videoQuality" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="highest" data-i18n="download.qualityHighest">最高品質</option>
                    <option value="1080p">1080p</option>
                    <option value="720p">720p</option>
                    <option value="480p">480p</option>
                    <option value="360p">360p</option>
                </select>
            </div>
            <div class="youtube-warning" style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 10px; margin-top: 10px;">
                <strong data-i18n="download.youtubeWarning">注意:</strong>
                <span data-i18n="download.youtubeWarningText">YouTube動画のダウンロードは利用規約に注意してください。個人利用のみで、著作権を尊重してください。</span>
            </div>
        </div>

        <button id="downloadBtn" class="download-button" data-i18n="download.downloadButton">ダウンロード</button>

        <div id="statusMessage" class="status-message"></div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const urlInput = document.getElementById('urlInput');
    const filenameInput = document.getElementById('filenameInput');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusMessage = document.getElementById('statusMessage');
    const enhanceQualityCheckbox = document.getElementById('enhanceQuality');
    const resolutionOptions = document.getElementById('resolutionOptions');
    const resolutionSelect = document.getElementById('resolutionSelect');
    const youtubeOptions = document.getElementById('youtubeOptions');
    const formatSelect = document.getElementById('formatSelect');
    const videoQualityGroup = document.getElementById('videoQualityGroup');
    const videoQuality = document.getElementById('videoQuality');
    
    // 画質向上チェックボックスの変更イベント
    enhanceQualityCheckbox.addEventListener('change', function() {
        resolutionOptions.style.display = this.checked ? 'block' : 'none';
    });
    
    // フォーマット選択の変更イベント
    formatSelect.addEventListener('change', function() {
        videoQualityGroup.style.display = this.value === 'video' ? 'block' : 'none';
    });
    
    // URL入力の変更イベント（YouTube検出）
    urlInput.addEventListener('input', function() {
        const url = this.value;
        const isYouTube = isYouTubeUrl(url);
        
        if (isYouTube) {
            youtubeOptions.style.display = 'block';
            enhanceQualityCheckbox.parentElement.parentElement.style.display = 'none';
        } else {
            youtubeOptions.style.display = 'none';
            enhanceQualityCheckbox.parentElement.parentElement.style.display = 'block';
        }
    });
    
    // ファイル名入力で拡張子候補を動的に更新
    filenameInput.addEventListener('input', function() {
        const value = this.value;
        const lastDot = value.lastIndexOf('.');
        if (lastDot > -1) {
            const base = value.substring(0, lastDot);
            const datalist = document.getElementById('extensionList');
            
            // オプションを更新して、現在のファイル名に拡張子を追加
            Array.from(datalist.options).forEach(option => {
                option.value = base + option.textContent;
            });
        }
    });
    
    function isYouTubeUrl(url) {
        return url.includes('youtube.com/watch') || 
               url.includes('youtu.be/') || 
               url.includes('youtube.com/shorts/');
    }
    
    function extractYouTubeId(url) {
        const patterns = [
            /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/shorts\/)([^&\n?#]+)/,
        ];
        
        for (const pattern of patterns) {
            const match = url.match(pattern);
            if (match) return match[1];
        }
        return null;
    }

    function showStatus(message, type) {
        statusMessage.textContent = message;
        statusMessage.className = `status-message ${type}`;
        statusMessage.style.display = 'block';
    }

    function hideStatus() {
        statusMessage.style.display = 'none';
    }

    function extractFilenameFromUrl(url, mimeType) {
        try {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            let filename = pathname.split('/').pop();
            
            // クエリパラメータを除去
            if (filename) {
                filename = filename.split('?')[0];
            }
            
            // URLパラメータやクエリから元のファイル名を取得（Fandomなどのサイト用）
            const fileParam = urlObj.searchParams.get('file');
            if (fileParam) {
                filename = fileParam.split('/').pop();
            }
            
            // URLパラメータにformat,webpが含まれているかチェック
            const hasWebPFormat = url.includes('format,webp') || url.includes('format=webp');
            
            // 元がGIFかどうか判定
            const isOriginallyGif = (filename && filename.toLowerCase().includes('.gif')) ||
                                   url.includes('gif') ||
                                   (fileParam && fileParam.toLowerCase().includes('.gif'));
            
            // URLにファイル名が含まれていない場合、またはファイル名に拡張子がない場合
            if (!filename || filename === '' || !filename.includes('.')) {
                // MIMEタイプから拡張子を決定
                const extension = getExtensionFromMimeType(mimeType);
                if (!filename || filename === '') {
                    filename = 'download' + extension;
                } else {
                    filename = filename + extension;
                }
            } else {
                // WebPに変換されている場合の処理
                if (hasWebPFormat || mimeType === 'image/webp') {
                    const lastDotIndex = filename.lastIndexOf('.');
                    if (lastDotIndex !== -1) {
                        const nameWithoutExt = filename.substring(0, lastDotIndex);
                        
                        // 元がGIFならGIFとして保存
                        if (isOriginallyGif) {
                            filename = nameWithoutExt + '.gif';
                        } else {
                            // GIF以外はJPGに変換
                            filename = nameWithoutExt + '.jpg';
                        }
                    }
                } else {
                    // 画像ファイルの拡張子を適切に変更
                    filename = adjustImageExtension(filename, mimeType);
                }
            }
            
            return filename;
        } catch (e) {
            return 'download';
        }
    }

    function getExtensionFromMimeType(mimeType) {
        if (!mimeType) return '';
        
        const mimeToExt = {
            'image/jpeg': '.jpg',
            'image/jpg': '.jpg',
            'image/png': '.png',
            'image/gif': '.gif',
            'image/webp': '.jpg', // WebPはJPGに変換
            'image/bmp': '.bmp',
            'image/svg+xml': '.svg',
            'image/x-icon': '.ico',
            'image/tiff': '.tiff',
            'text/plain': '.txt',
            'text/html': '.html',
            'application/json': '.json',
            'application/xml': '.xml',
            'application/zip': '.zip',
            'application/x-rar-compressed': '.rar',
            'application/x-7z-compressed': '.7z',
            'video/mp4': '.mp4',
            'video/webm': '.webm',
            'audio/mpeg': '.mp3',
            'audio/wav': '.wav'
        };
        
        return mimeToExt[mimeType] || '';
    }

    function adjustImageExtension(filename, mimeType) {
        if (!mimeType || !mimeType.startsWith('image/')) {
            return filename;
        }
        
        // 現在の拡張子を取得
        const lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex === -1) {
            return filename + getExtensionFromMimeType(mimeType);
        }
        
        const nameWithoutExt = filename.substring(0, lastDotIndex);
        const currentExt = filename.substring(lastDotIndex).toLowerCase();
        
        // WebP、AVIF、その他の形式をJPGに変換
        if (currentExt === '.webp' || currentExt === '.avif' || currentExt === '.jfif') {
            return nameWithoutExt + '.jpg';
        }
        
        // GIFはそのまま保持
        if (currentExt === '.gif') {
            return filename;
        }
        
        // PNGとJPG/JPEGは適切に保持
        if (currentExt === '.png' || currentExt === '.jpg' || currentExt === '.jpeg') {
            return filename;
        }
        
        // その他の画像形式はMIMEタイプに基づいて決定
        return nameWithoutExt + getExtensionFromMimeType(mimeType);
    }

    async function convertImageBlob(blob, targetFormat, enhanceQuality = false) {
        return new Promise((resolve) => {
            const img = new Image();
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            img.onload = function() {
                let width = img.width;
                let height = img.height;
                
                // 画質向上モード：解像度を上げる
                if (enhanceQuality) {
                    // 元のサイズが小さい場合は2倍または4倍にアップスケール
                    const scaleFactor = (width < 500 || height < 500) ? 4 : 2;
                    width *= scaleFactor;
                    height *= scaleFactor;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                // 画質向上のための設定
                if (enhanceQuality) {
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // シャープネスフィルターの適用
                    ctx.filter = 'contrast(1.1) saturate(1.1)';
                }
                
                ctx.drawImage(img, 0, 0, width, height);
                
                // 画質を最高にして保存
                const quality = enhanceQuality ? 1.0 : 0.95;
                
                canvas.toBlob(function(newBlob) {
                    resolve(newBlob);
                }, targetFormat, quality);
            };
            
            img.src = URL.createObjectURL(blob);
        });
    }

    // 超解像アルゴリズム - ESRGAN風の実装
    function superResolutionFilter(imageData, scale) {
        const width = imageData.width;
        const height = imageData.height;
        const data = imageData.data;
        const newWidth = width * scale;
        const newHeight = height * scale;
        
        // 新しい画像データを作成
        const newCanvas = document.createElement('canvas');
        const newCtx = newCanvas.getContext('2d');
        newCanvas.width = newWidth;
        newCanvas.height = newHeight;
        const newImageData = newCtx.createImageData(newWidth, newHeight);
        const newData = newImageData.data;
        
        // Bicubic補間係数を計算
        function cubicInterpolate(p0, p1, p2, p3, t) {
            const a0 = p3 - p2 - p0 + p1;
            const a1 = p0 - p1 - a0;
            const a2 = p2 - p0;
            const a3 = p1;
            return a0 * t * t * t + a1 * t * t + a2 * t + a3;
        }
        
        // 各ピクセルを補間
        for (let y = 0; y < newHeight; y++) {
            for (let x = 0; x < newWidth; x++) {
                const srcX = x / scale;
                const srcY = y / scale;
                const x0 = Math.floor(srcX);
                const y0 = Math.floor(srcY);
                const fx = srcX - x0;
                const fy = srcY - y0;
                
                // 4x4の周囲ピクセルを取得して補間
                for (let c = 0; c < 3; c++) {
                    const values = [];
                    for (let py = -1; py <= 2; py++) {
                        const row = [];
                        for (let px = -1; px <= 2; px++) {
                            const sx = Math.min(Math.max(x0 + px, 0), width - 1);
                            const sy = Math.min(Math.max(y0 + py, 0), height - 1);
                            row.push(data[(sy * width + sx) * 4 + c]);
                        }
                        values.push(row);
                    }
                    
                    // Bicubic補間を適用
                    const cols = [];
                    for (let i = 0; i < 4; i++) {
                        cols.push(cubicInterpolate(values[i][0], values[i][1], values[i][2], values[i][3], fx));
                    }
                    const result = cubicInterpolate(cols[0], cols[1], cols[2], cols[3], fy);
                    
                    newData[(y * newWidth + x) * 4 + c] = Math.min(255, Math.max(0, Math.round(result)));
                }
                newData[(y * newWidth + x) * 4 + 3] = 255; // Alpha
            }
        }
        
        return newImageData;
    }
    
    // ディテール強調フィルター
    function enhanceDetails(imageData) {
        const width = imageData.width;
        const height = imageData.height;
        const data = imageData.data;
        const output = new Uint8ClampedArray(data);
        
        // アンシャープマスク（強力版）
        const radius = 2;
        const amount = 1.5; // 強度を上げる
        
        for (let y = radius; y < height - radius; y++) {
            for (let x = radius; x < width - radius; x++) {
                const idx = (y * width + x) * 4;
                
                for (let c = 0; c < 3; c++) {
                    let blurred = 0;
                    let weight = 0;
                    
                    // ガウシアンブラー
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const w = Math.exp(-(dist * dist) / (2 * radius * radius));
                            const nIdx = ((y + dy) * width + (x + dx)) * 4 + c;
                            blurred += data[nIdx] * w;
                            weight += w;
                        }
                    }
                    blurred /= weight;
                    
                    // アンシャープマスクを適用
                    const sharp = data[idx + c] + (data[idx + c] - blurred) * amount;
                    output[idx + c] = Math.min(255, Math.max(0, Math.round(sharp)));
                }
            }
        }
        
        return output;
    }
    
    // ノイズ除去とテクスチャ復元
    function denoiseAndRestoreTexture(imageData) {
        const width = imageData.width;
        const height = imageData.height;
        const data = new Uint8ClampedArray(imageData.data);
        
        // Non-local means風のノイズ除去
        for (let y = 2; y < height - 2; y++) {
            for (let x = 2; x < width - 2; x++) {
                const idx = (y * width + x) * 4;
                
                for (let c = 0; c < 3; c++) {
                    const patches = [];
                    const centerPatch = [];
                    
                    // 中心パッチを取得
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nIdx = ((y + dy) * width + (x + dx)) * 4 + c;
                            centerPatch.push(data[nIdx]);
                        }
                    }
                    
                    // 周囲のパッチと比較
                    for (let py = -2; py <= 2; py++) {
                        for (let px = -2; px <= 2; px++) {
                            if (px === 0 && py === 0) continue;
                            
                            const patch = [];
                            let valid = true;
                            
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const ny = y + py + dy;
                                    const nx = x + px + dx;
                                    if (ny < 0 || ny >= height || nx < 0 || nx >= width) {
                                        valid = false;
                                        break;
                                    }
                                    const nIdx = (ny * width + nx) * 4 + c;
                                    patch.push(data[nIdx]);
                                }
                                if (!valid) break;
                            }
                            
                            if (valid) {
                                // パッチの類似度を計算
                                let diff = 0;
                                for (let i = 0; i < 9; i++) {
                                    diff += Math.abs(centerPatch[i] - patch[i]);
                                }
                                const weight = Math.exp(-diff / 50);
                                patches.push({ value: data[((y + py) * width + (x + px)) * 4 + c], weight });
                            }
                        }
                    }
                    
                    // 重み付き平均
                    if (patches.length > 0) {
                        let sum = data[idx + c] * 0.5; // 元の値も考慮
                        let weightSum = 0.5;
                        
                        for (const patch of patches) {
                            sum += patch.value * patch.weight;
                            weightSum += patch.weight;
                        }
                        
                        data[idx + c] = Math.round(sum / weightSum);
                    }
                }
            }
        }
        
        imageData.data.set(data);
        return imageData;
    }
    
    // 新しいAIエンハンサーを使用
    async function enhanceImageQuality(blob, targetResolution = 'auto') {
        // AIエンハンサーが利用可能な場合はそれを使用
        if (window.AIImageEnhancer) {
            console.log('AI画質向上エンジンを使用します...');
            const enhancer = new AIImageEnhancer();
            return await enhancer.enhance(blob, targetResolution);
        }
        
        // フォールバック: 従来の処理
        console.log('従来の画質向上処理を使用します...');
        return new Promise((resolve) => {
            const img = new Image();
            
            img.onload = function() {
                // 元画像のサイズ
                const originalWidth = img.width;
                const originalHeight = img.height;
                const aspectRatio = originalWidth / originalHeight;
                
                let width, height;
                
                // 解像度設定に基づいて目標サイズを決定
                switch(targetResolution) {
                    case '4k':
                        if (aspectRatio > 16/9) {
                            width = 3840;
                            height = Math.round(3840 / aspectRatio);
                        } else {
                            height = 2160;
                            width = Math.round(2160 * aspectRatio);
                        }
                        break;
                    case '1440p':
                        if (aspectRatio > 16/9) {
                            width = 2560;
                            height = Math.round(2560 / aspectRatio);
                        } else {
                            height = 1440;
                            width = Math.round(1440 * aspectRatio);
                        }
                        break;
                    case '1080p':
                        if (aspectRatio > 16/9) {
                            width = 1920;
                            height = Math.round(1920 / aspectRatio);
                        } else {
                            height = 1080;
                            width = Math.round(1080 * aspectRatio);
                        }
                        break;
                    case '720p':
                        if (aspectRatio > 16/9) {
                            width = 1280;
                            height = Math.round(1280 / aspectRatio);
                        } else {
                            height = 720;
                            width = Math.round(720 * aspectRatio);
                        }
                        break;
                    case 'original':
                        width = originalWidth;
                        height = originalHeight;
                        break;
                    case 'auto':
                    default:
                        let scaleFactor = 2;
                        if (originalWidth < 400 || originalHeight < 400) {
                            scaleFactor = 4;
                        } else if (originalWidth < 800 || originalHeight < 800) {
                            scaleFactor = 3;
                        } else if (originalWidth > 1500 || originalHeight > 1500) {
                            scaleFactor = 1.5;
                        }
                        width = Math.round(originalWidth * scaleFactor);
                        height = Math.round(originalHeight * scaleFactor);
                        
                        if (width > 3840) {
                            const scale = 3840 / width;
                            width = 3840;
                            height = Math.round(height * scale);
                        }
                        if (height > 2160) {
                            const scale = 2160 / height;
                            height = 2160;
                            width = Math.round(width * scale);
                        }
                        break;
                }
                
                // 元画像より小さくしない（originalモード以外）
                if (targetResolution !== 'original') {
                    if (width < originalWidth) width = originalWidth;
                    if (height < originalHeight) height = originalHeight;
                }
                
                // 処理用のキャンバスを作成
                const srcCanvas = document.createElement('canvas');
                const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });
                srcCanvas.width = originalWidth;
                srcCanvas.height = originalHeight;
                srcCtx.drawImage(img, 0, 0);
                
                // 元画像のデータを取得
                let imageData = srcCtx.getImageData(0, 0, originalWidth, originalHeight);
                
                // Step 1: ノイズ除去とテクスチャ復元
                console.log('ノイズ除去を実行中...');
                imageData = denoiseAndRestoreTexture(imageData);
                srcCtx.putImageData(imageData, 0, 0);
                
                // Step 2: 超解像処理（段階的に拡大）
                let currentScale = 1;
                const targetScale = Math.max(width / originalWidth, height / originalHeight);
                
                while (currentScale < targetScale) {
                    const stepScale = Math.min(2, targetScale / currentScale);
                    console.log(`超解像処理中... ${Math.round(currentScale * 100)}% → ${Math.round(currentScale * stepScale * 100)}%`);
                    
                    // 現在のサイズを取得
                    const currentWidth = Math.round(originalWidth * currentScale);
                    const currentHeight = Math.round(originalHeight * currentScale);
                    
                    // 超解像フィルターを適用
                    imageData = srcCtx.getImageData(0, 0, currentWidth, currentHeight);
                    const scaledData = superResolutionFilter(imageData, stepScale);
                    
                    // 新しいサイズのキャンバスに描画
                    const newWidth = Math.round(currentWidth * stepScale);
                    const newHeight = Math.round(currentHeight * stepScale);
                    srcCanvas.width = newWidth;
                    srcCanvas.height = newHeight;
                    srcCtx.putImageData(scaledData, 0, 0);
                    
                    currentScale *= stepScale;
                }
                
                // Step 3: 最終サイズに調整
                const finalCanvas = document.createElement('canvas');
                const finalCtx = finalCanvas.getContext('2d', { willReadFrequently: true });
                finalCanvas.width = width;
                finalCanvas.height = height;
                
                // 高品質な補間で最終サイズに
                finalCtx.imageSmoothingEnabled = true;
                finalCtx.imageSmoothingQuality = 'high';
                finalCtx.drawImage(srcCanvas, 0, 0, width, height);
                
                // Step 4: ディテール強調
                console.log('ディテール強調中...');
                let finalImageData = finalCtx.getImageData(0, 0, width, height);
                const enhancedData = enhanceDetails(finalImageData);
                finalImageData.data.set(enhancedData);
                finalCtx.putImageData(finalImageData, 0, 0);
                
                // Step 5: 最終的な画質調整
                const outputCanvas = document.createElement('canvas');
                const outputCtx = outputCanvas.getContext('2d');
                outputCanvas.width = width;
                outputCanvas.height = height;
                
                // コントラストと彩度を強化
                outputCtx.filter = 'contrast(1.15) saturate(1.1) brightness(1.02)';
                outputCtx.drawImage(finalCanvas, 0, 0);
                
                // 高画質で保存
                const outputFormat = blob.type === 'image/png' ? 'image/png' : 'image/jpeg';
                const quality = 1.0; // 最高品質で保存
                
                outputCanvas.toBlob(function(newBlob) {
                    console.log(`画質向上完了: ${originalWidth}x${originalHeight} → ${width}x${height}`);
                    console.log(`ファイルサイズ: ${(blob.size/1024).toFixed(1)}KB → ${(newBlob.size/1024).toFixed(1)}KB`);
                    resolve(newBlob);
                }, outputFormat, quality);
            };
            
            img.src = URL.createObjectURL(blob);
        });
    }

    async function convertToGif(blob) {
        // WebPアニメーションからGIFへの変換は複雑なため、
        // 静止画として保存するか、元のWebPをGIFとして保存
        // ブラウザの制限により、完全なアニメーション変換は困難
        return blob;
    }

    // FandomのようなWikiサイトから実際の画像URLを取得
    async function extractActualImageUrl(url) {
        // FandomのWikiページの場合
        if (url.includes('fandom.com') && url.includes('wiki')) {
            try {
                showStatus('Wikiページから画像を取得しています...', 'info');
                
                // URLからファイル名を抽出
                const urlObj = new URL(url);
                const fileParam = urlObj.searchParams.get('file');
                
                if (fileParam) {
                    // Wikiページをフェッチして実際の画像URLを探す
                    try {
                        // CORSプロキシ経由でページを取得
                        const pageUrl = url.split('?')[0]; // クエリパラメータを除去
                        const proxyPageUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
                        
                        const pageResponse = await fetch(proxyPageUrl);
                        if (pageResponse.ok) {
                            const pageText = await pageResponse.text();
                            
                            // 画像URLを正規表現で探す
                            // パターン1: static.wikia.nocookie.net のURL
                            const imgUrlPattern = /https:\/\/static\.wikia\.nocookie\.net\/[^"'\s]+\.gif/gi;
                            const matches = pageText.match(imgUrlPattern);
                            
                            if (matches && matches.length > 0) {
                                // ファイル名に一致する画像URLを探す
                                const targetFilename = fileParam.toLowerCase();
                                for (const match of matches) {
                                    if (match.toLowerCase().includes(targetFilename.replace(/_/g, ''))) {
                                        console.log('Found actual image URL:', match);
                                        // /revision/latest を削除してオリジナル画像を取得
                                        const cleanUrl = match.split('/revision/')[0];
                                        return cleanUrl;
                                    }
                                }
                                
                                // 一致するものが見つからない場合は最初のGIFを使用
                                console.log('Using first GIF found:', matches[0]);
                                return matches[0].split('/revision/')[0];
                            }
                        }
                    } catch (e) {
                        console.log('Failed to fetch Wiki page:', e);
                    }
                    
                    // フォールバック: 直接URLを推測
                    showStatus('画像URLを推測しています...', 'info');
                    
                    // 実際のMinecraft WikiのGIF URLの例:
                    // https://static.wikia.nocookie.net/minecraft_gamepedia/images/e/ed/Enchanted_Stone_Sword.gif
                    const wikiName = url.match(/https?:\/\/([^.]+)\.fandom\.com/)?.[1] || 'minecraft';
                    
                    // よく使われるハッシュパターン
                    const hashes = ['e/ed', 'a/ab', '1/1a', '2/2b', '3/3c', '4/4d', '5/5e', '6/6f', '7/7a', '8/8b', '9/9c', '0/0a', 'b/bc', 'c/cd', 'd/de', 'f/fa'];
                    
                    for (const hash of hashes) {
                        const testUrl = `https://static.wikia.nocookie.net/${wikiName}_gamepedia/images/${hash}/${fileParam}`;
                        console.log('Trying URL pattern:', testUrl);
                        
                        // URLが有効か確認
                        try {
                            const testResponse = await fetch('https://corsproxy.io/?' + encodeURIComponent(testUrl), {
                                method: 'HEAD'
                            });
                            if (testResponse.ok) {
                                console.log('Found working URL:', testUrl);
                                return testUrl;
                            }
                        } catch (e) {
                            // 次のパターンを試す
                        }
                    }
                }
            } catch (e) {
                console.log('Failed to extract Fandom image URL:', e);
            }
        }
        
        // 他の画像直接URLの場合はそのまま返す
        if (url.includes('static.wikia.nocookie.net') || 
            url.includes('.gif') || 
            url.includes('.jpg') || 
            url.includes('.png') ||
            url.includes('.webp')) {
            return url;
        }
        
        return url;
    }

    // YouTube Innertube APIを使用して動画情報を取得
    async function getYouTubeVideoInfo(videoId) {
        try {
            showStatus('動画情報を取得中...', 'info');
            
            // YouTube Innertube API (YouTube内部API)
            const apiKey = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8'; // 公開APIキー
            const innertubeUrl = 'https://www.youtube.com/youtubei/v1/player';
            
            const requestBody = {
                videoId: videoId,
                context: {
                    client: {
                        hl: 'ja',
                        gl: 'JP',
                        clientName: 'WEB',
                        clientVersion: '2.20231219.01.00',
                        platform: 'DESKTOP'
                    }
                }
            };
            
            const response = await fetch(`https://corsproxy.io/?${encodeURIComponent(innertubeUrl + '?key=' + apiKey)}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });
            
            if (response.ok) {
                const data = await response.json();
                return data;
            }
            
            // フォールバック: oEmbed API
            const oembedUrl = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
            const oembedResponse = await fetch('https://corsproxy.io/?' + encodeURIComponent(oembedUrl));
            const oembedData = await oembedResponse.json();
            
            return {
                videoDetails: {
                    title: oembedData.title,
                    author: oembedData.author_name,
                    videoId: videoId
                }
            };
        } catch (error) {
            console.error('Failed to get video info:', error);
            return null;
        }
    }
    
    async function getYouTubeStreams(videoId) {
        try {
            // YouTube動画ページから直接ストリーム情報を取得
            const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`;
            const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(videoPageUrl);
            
            showStatus('動画情報を解析中...', 'info');
            const response = await fetch(proxyUrl);
            const html = await response.text();
            
            // ytInitialPlayerResponseを探す
            const ytConfigMatch = html.match(/ytInitialPlayerResponse\s*=\s*({.+?});/);
            if (ytConfigMatch) {
                const playerResponse = JSON.parse(ytConfigMatch[1]);
                
                if (playerResponse.streamingData) {
                    const formats = [
                        ...(playerResponse.streamingData.formats || []),
                        ...(playerResponse.streamingData.adaptiveFormats || [])
                    ];
                    
                    return formats.map(format => ({
                        itag: format.itag,
                        url: format.url || format.signatureCipher,
                        mimeType: format.mimeType,
                        quality: format.quality,
                        qualityLabel: format.qualityLabel,
                        hasAudio: format.audioQuality ? true : false,
                        hasVideo: format.width ? true : false,
                        width: format.width,
                        height: format.height,
                        contentLength: format.contentLength,
                        audioQuality: format.audioQuality
                    }));
                }
            }
            
            return [];
        } catch (error) {
            console.error('Failed to get streams:', error);
            return [];
        }
    }
    
    // signatureCipherをデコードして実際のURLを取得
    function decodeSignatureCipher(signatureCipher) {
        const params = new URLSearchParams(signatureCipher);
        const url = params.get('url');
        const sp = params.get('sp') || 'signature';
        const s = params.get('s');
        
        if (url && s) {
            // シグネチャーのデコード（簡易版）
            // 実際にはYouTubeのJavaScriptプレーヤーからデコード関数を抽出する必要がある
            const decodedSig = decodeSignature(s);
            return `${url}&${sp}=${encodeURIComponent(decodedSig)}`;
        }
        return null;
    }
    
    // YouTubeシグネチャーのデコード（簡易実装）
    function decodeSignature(sig) {
        // これは例示的な実装です。実際のデコードアルゴリズムはより複雑です
        return sig.split('').reverse().join('');
    }
    
    // 動画・音声データをダウンロードして結合
    async function downloadAndMergeStreams(videoUrl, audioUrl, filename) {
        try {
            showStatus('動画データをダウンロード中...', 'info');
            
            // Blob形式でダウンロード
            const videoResponse = await fetch(`https://corsproxy.io/?${encodeURIComponent(videoUrl)}`);
            const videoBlob = await videoResponse.blob();
            
            if (audioUrl) {
                showStatus('音声データをダウンロード中...', 'info');
                const audioResponse = await fetch(`https://corsproxy.io/?${encodeURIComponent(audioUrl)}`);
                const audioBlob = await audioResponse.blob();
                
                // ブラウザ上での動画・音声の結合は複雑なため、
                // 個別にダウンロードして、ユーザーに結合を促す
                const videoLink = document.createElement('a');
                videoLink.href = URL.createObjectURL(videoBlob);
                videoLink.download = filename.replace('.mp4', '_video.mp4');
                videoLink.click();
                
                const audioLink = document.createElement('a');
                audioLink.href = URL.createObjectURL(audioBlob);
                audioLink.download = filename.replace('.mp4', '_audio.mp3');
                audioLink.click();
                
                showStatus('動画と音声を別々にダウンロードしました。動画編集ソフトで結合してください。', 'info');
            } else {
                // 音声込みの動画の場合
                const link = document.createElement('a');
                link.href = URL.createObjectURL(videoBlob);
                link.download = filename;
                link.click();
                
                showStatus('ダウンロードが完了しました！', 'success');
            }
        } catch (error) {
            throw new Error('ダウンロード中にエラーが発生しました: ' + error.message);
        }
    }
    
    async function downloadYouTubeVideo(url, format, quality) {
        const videoId = extractYouTubeId(url);
        if (!videoId) {
            throw new Error('無効なYouTube URLです');
        }
        
        showStatus('YouTube動画情報を取得中...', 'info');
        
        try {
            // Innertube APIで動画情報を取得
            const videoInfo = await getYouTubeVideoInfo(videoId);
            
            if (!videoInfo || !videoInfo.streamingData) {
                // ページから直接ストリーム情報を取得
                const streams = await getYouTubeStreams(videoId);
                
                if (!streams || streams.length === 0) {
                    throw new Error('動画ストリームが見つかりません');
                }
                
                // レガシー処理にフォールバック
                await handleLegacyDownload(streams, format, quality, videoInfo);
                return;
            }
            
            // ストリーミングデータから適切なフォーマットを選択
            const formats = [
                ...(videoInfo.streamingData.formats || []),
                ...(videoInfo.streamingData.adaptiveFormats || [])
            ];
            
            let selectedVideo = null;
            let selectedAudio = null;
            
            if (format === 'audio') {
                // 音声のみ - 最高品質のオーディオを選択
                const audioFormats = formats.filter(f => 
                    f.mimeType && f.mimeType.startsWith('audio/')
                );
                
                selectedAudio = audioFormats.sort((a, b) => 
                    (b.bitrate || 0) - (a.bitrate || 0)
                )[0];
                
                if (selectedAudio) {
                    const audioUrl = selectedAudio.url || 
                        (selectedAudio.signatureCipher && decodeSignatureCipher(selectedAudio.signatureCipher));
                    
                    if (audioUrl) {
                        showStatus('音声をダウンロード中...', 'info');
                        
                        // 音声を直接ダウンロード
                        const link = document.createElement('a');
                        link.href = `https://corsproxy.io/?${encodeURIComponent(audioUrl)}`;
                        link.download = `${videoInfo.videoDetails?.title || videoId}.mp3`;
                        link.target = '_blank';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        showStatus('音声のダウンロードを開始しました', 'success');
                        return;
                    }
                }
            } else {
                // 動画 - 指定品質の動画と最高品質の音声を選択
                const videoFormats = formats.filter(f => 
                    f.mimeType && f.mimeType.startsWith('video/')
                );
                
                // 品質に応じた動画を選択
                if (quality === 'highest') {
                    selectedVideo = videoFormats.sort((a, b) => 
                        (b.height || 0) - (a.height || 0)
                    )[0];
                } else {
                    const targetHeight = parseInt(quality.replace('p', ''));
                    selectedVideo = videoFormats.find(f => f.height === targetHeight) ||
                                  videoFormats.find(f => f.height <= targetHeight) ||
                                  videoFormats[0];
                }
                
                // 音声トラックを持つフォーマットかチェック
                if (selectedVideo && selectedVideo.audioQuality) {
                    // 音声込みの動画
                    const videoUrl = selectedVideo.url || 
                        (selectedVideo.signatureCipher && decodeSignatureCipher(selectedVideo.signatureCipher));
                    
                    if (videoUrl) {
                        showStatus('動画をダウンロード中...', 'info');
                        
                        const link = document.createElement('a');
                        link.href = `https://corsproxy.io/?${encodeURIComponent(videoUrl)}`;
                        link.download = `${videoInfo.videoDetails?.title || videoId}.mp4`;
                        link.target = '_blank';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        showStatus('動画のダウンロードを開始しました', 'success');
                        return;
                    }
                } else {
                    // 動画と音声を別々にダウンロード
                    const audioFormats = formats.filter(f => 
                        f.mimeType && f.mimeType.startsWith('audio/')
                    );
                    selectedAudio = audioFormats.sort((a, b) => 
                        (b.bitrate || 0) - (a.bitrate || 0)
                    )[0];
                    
                    if (selectedVideo && selectedAudio) {
                        const videoUrl = selectedVideo.url || 
                            (selectedVideo.signatureCipher && decodeSignatureCipher(selectedVideo.signatureCipher));
                        const audioUrl = selectedAudio.url || 
                            (selectedAudio.signatureCipher && decodeSignatureCipher(selectedAudio.signatureCipher));
                        
                        if (videoUrl && audioUrl) {
                            const filename = `${videoInfo.videoDetails?.title || videoId}.mp4`;
                            await downloadAndMergeStreams(videoUrl, audioUrl, filename);
                            return;
                        }
                    }
                }
            }
            
            throw new Error('適切なストリームが見つかりませんでした');
            
        } catch (error) {
            console.error('YouTube download error:', error);
            showStatus(`エラー: ${error.message}`, 'error');
            
            // エラー時は手動ダウンロード用のUIを表示
            showManualDownloadUI(videoId);
        }
    }
    
    // 手動ダウンロード用のUI表示
    function showManualDownloadUI(videoId) {
        const modalHtml = `
            <div id="ytDownloadModal" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); 
                z-index: 10000; max-width: 500px;">
                <h3>YouTube動画ダウンロード</h3>
                <p>自動ダウンロードができませんでした。以下の方法をお試しください：</p>
                <ol>
                    <li>ブラウザの拡張機能を使用する</li>
                    <li>デスクトップアプリ（youtube-dl、yt-dlp）を使用する</li>
                    <li>オンラインサービスを利用する</li>
                </ol>
                <p>動画ID: <code>${videoId}</code></p>
                <button onclick="document.getElementById('ytDownloadModal').remove()" 
                    style="background: #4CAF50; color: white; border: none; padding: 10px 20px; 
                    border-radius: 4px; cursor: pointer;">閉じる</button>
            </div>
            <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
                background: rgba(0,0,0,0.5); z-index: 9999;" 
                onclick="document.getElementById('ytDownloadModal').remove()"></div>
        `;
        
        const modalDiv = document.createElement('div');
        modalDiv.innerHTML = modalHtml;
        document.body.appendChild(modalDiv);
    }
    
    // レガシー処理のハンドラー
    async function handleLegacyDownload(streams, format, quality, videoInfo) {
        // 既存のストリーム処理ロジック
        let selectedStream = null;
        
        if (format === 'audio') {
            const audioStreams = streams.filter(s => s.hasAudio && !s.hasVideo);
            selectedStream = audioStreams[0];
        } else {
            const videoStreams = streams.filter(s => s.hasVideo);
            selectedStream = videoStreams[0];
        }
        
        if (selectedStream && selectedStream.url) {
            const link = document.createElement('a');
            link.href = selectedStream.url;
            link.download = `video.${format === 'audio' ? 'mp3' : 'mp4'}`;
            link.target = '_blank';
            link.click();
            showStatus('ダウンロードを開始しました', 'success');
        } else {
            throw new Error('ストリームが見つかりません');
        }
    }
    
    async function downloadFile(url, filename) {
        try {
            downloadBtn.disabled = true;
            downloadBtn.innerHTML = `<span data-i18n="download.downloading">ダウンロード中</span><span class="loading"></span>`;
            
            // YouTubeの場合
            if (isYouTubeUrl(url)) {
                const format = formatSelect.value;
                const quality = videoQuality.value;
                await downloadYouTubeVideo(url, format, quality);
                return;
            }
            
            // FandomのようなWikiサイトの場合、実際の画像URLを取得
            const actualUrl = await extractActualImageUrl(url);
            if (actualUrl !== url) {
                console.log('Using actual image URL:', actualUrl);
                url = actualUrl;
            }
            
            // まずHEADリクエストでMIMEタイプを確認
            let mimeType = null;
            try {
                const headResponse = await fetch(url, {
                    method: 'HEAD',
                    mode: 'cors',
                    credentials: 'omit'
                });
                mimeType = headResponse.headers.get('content-type');
            } catch (e) {
                console.log('HEAD request failed, continuing with GET');
            }
            
            const response = await fetch(url, {
                mode: 'cors',
                credentials: 'omit'
            }).catch(async (error) => {
                // CORS エラーの場合、プロキシ経由で試す
                console.log('Direct fetch failed, trying proxy method');
                
                // CORSプロキシを使用（公開プロキシサービス）
                const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
                try {
                    const proxyResponse = await fetch(proxyUrl);
                    if (proxyResponse.ok) {
                        return proxyResponse;
                    }
                } catch (proxyError) {
                    console.log('Proxy also failed');
                }
                
                // WikiページのURLの場合、直接画像を開くリンクを提供
                if (url.includes('wiki') && (url.includes('file=') || url.includes('File:'))) {
                    showStatus('Wikiページです。画像を直接開くには、ページ内の画像を右クリックして「画像を新しいタブで開く」を選択し、その画像URLをここに貼り付けてください。', 'info');
                    throw new Error('Wikiページから直接ダウンロードできません。画像の直接URLが必要です。');
                }
                
                // 最終手段: 新しいタブで開く
                const link = document.createElement('a');
                link.href = url;
                link.download = filename || 'download';
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                throw new Error('CORS制限により直接ダウンロードできません。新しいタブで開きます。');
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            let blob = await response.blob();
            if (!mimeType) {
                mimeType = blob.type;
            }
            
            // 画像の形式変換処理
            if (mimeType && mimeType.startsWith('image/')) {
                const urlPath = new URL(url).pathname.toLowerCase();
                const originalFilename = urlPath.split('/').pop() || '';
                const shouldEnhance = enhanceQualityCheckbox.checked;
                
                // URLやファイル名から元の形式を判定
                const isOriginallyGif = originalFilename.includes('.gif') || 
                                       url.includes('gif') || 
                                       url.includes('file=') && url.includes('.gif');
                
                // 画質向上処理（GIF以外の画像）
                if (shouldEnhance && !isOriginallyGif) {
                    const selectedResolution = resolutionSelect.value;
                    const originalSize = blob.size;
                    const resText = selectedResolution === 'auto' ? '自動' : selectedResolution.toUpperCase();
                    showStatus(`画質を向上させています... (${resText}にアップスケーリング中)`, 'info');
                    blob = await enhanceImageQuality(blob, selectedResolution);
                    const newSize = blob.size;
                    console.log(`File size: ${(originalSize/1024).toFixed(1)}KB → ${(newSize/1024).toFixed(1)}KB`);
                }
                
                // WebPやAVIFの処理
                if (mimeType === 'image/webp' || mimeType === 'image/avif') {
                    if (isOriginallyGif) {
                        // 元がGIFの場合はGIFとして保存（アニメーション保持のため変換しない）
                        showStatus('GIFファイルを処理中...', 'info');
                        // ファイル名の拡張子だけ.gifに変更
                        mimeType = 'image/gif';
                    } else {
                        // GIF以外はJPEGに変換
                        if (!shouldEnhance) {
                            showStatus('画像を変換中...', 'info');
                        }
                        blob = await convertImageBlob(blob, 'image/jpeg', shouldEnhance);
                        mimeType = 'image/jpeg';
                    }
                }
                // URLパラメータでWebP変換されている場合も処理
                else if (url.includes('format,webp') || url.includes('format=webp')) {
                    if (isOriginallyGif) {
                        // 元がGIFの場合はGIFとして扱う
                        showStatus('GIFファイルを処理中...', 'info');
                        mimeType = 'image/gif';
                    } else {
                        // GIF以外はJPEGに変換
                        if (!shouldEnhance) {
                            showStatus('画像を変換中...', 'info');
                        }
                        blob = await convertImageBlob(blob, 'image/jpeg', shouldEnhance);
                        mimeType = 'image/jpeg';
                    }
                }
                // 通常の画像で画質向上のみ行う場合
                else if (shouldEnhance && !isOriginallyGif) {
                    // 既に画質向上処理済み
                }
            }
            
            const downloadUrl = window.URL.createObjectURL(blob);
            
            // ファイル名の決定
            const finalFilename = filename || extractFilenameFromUrl(url, mimeType);
            
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = finalFilename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up
            setTimeout(() => {
                window.URL.revokeObjectURL(downloadUrl);
            }, 100);
            
            showStatus(`ダウンロードが完了しました: ${finalFilename}`, 'success');
        } catch (error) {
            console.error('Download error:', error);
            
            if (error.message.includes('CORS')) {
                showStatus(error.message, 'info');
            } else {
                showStatus(`エラー: ${error.message}`, 'error');
            }
        } finally {
            downloadBtn.disabled = false;
            downloadBtn.innerHTML = '<span data-i18n="download.downloadButton">ダウンロード</span>';
        }
    }

    downloadBtn.addEventListener('click', async function() {
        const url = urlInput.value.trim();
        const filename = filenameInput.value.trim();
        
        if (!url) {
            showStatus('URLを入力してください', 'error');
            return;
        }
        
        // URL検証
        try {
            new URL(url);
        } catch (e) {
            showStatus('有効なURLを入力してください', 'error');
            return;
        }
        
        hideStatus();
        await downloadFile(url, filename);
    });

    // Enterキーでダウンロード
    urlInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            downloadBtn.click();
        }
    });
    
    filenameInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            downloadBtn.click();
        }
    });
});

// 国際化対応 - JSONファイルから翻訳を読み込み
let translations = {};

async function loadTranslations() {
    try {
        const response = await fetch('/Drowse-Lab/assets/data/translations.json');
        translations = await response.json();
        
        // 言語切り替え機能との統合
        if (typeof window.loadLanguage === 'function') {
            window.loadLanguage();
        }
        
        // 初期言語を適用
        applyTranslations();
    } catch (error) {
        console.error('Failed to load translations:', error);
    }
}

function applyTranslations() {
    const lang = localStorage.getItem('selectedLanguage') || 'ja';
    const trans = translations[lang] || translations['ja'];
    
    // data-i18n属性を持つ要素を更新
    document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (trans[key]) {
            element.textContent = trans[key];
        }
    });
    
    // placeholder属性を更新
    document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
        const key = element.getAttribute('data-i18n-placeholder');
        if (trans[key]) {
            element.placeholder = trans[key];
        }
    });
}

// ページ読み込み時に翻訳を読み込む
loadTranslations();

// 言語切り替えボタンのイベントリスナー
document.addEventListener('DOMContentLoaded', function() {
    const langToggleBtn = document.getElementById('langToggleBottom');
    if (langToggleBtn) {
        langToggleBtn.addEventListener('click', function() {
            const currentLang = localStorage.getItem('selectedLanguage') || 'ja';
            const newLang = currentLang === 'ja' ? 'en' : 'ja';
            localStorage.setItem('selectedLanguage', newLang);
            applyTranslations();
        });
    }
});
</script>