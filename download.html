---
layout: page
title: ファイルダウンロード
permalink: /download.html
hide_title: true
---

<style>
    .download-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 40px 20px;
    }

    .download-header {
        text-align: center;
        margin-bottom: 40px;
    }

    .download-header h1 {
        color: #333;
        margin-bottom: 10px;
    }

    .download-header p {
        color: #666;
    }

    .download-form {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 30px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .form-group {
        margin-bottom: 20px;
    }

    .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #333;
    }

    .form-group input {
        width: 100%;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        transition: border-color 0.3s;
    }

    .form-group input:focus {
        outline: none;
        border-color: #4CAF50;
        box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.1);
    }

    .download-button {
        width: 100%;
        padding: 14px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.3s;
    }

    .download-button:hover {
        background: #45a049;
    }

    .download-button:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    .status-message {
        margin-top: 20px;
        padding: 12px;
        border-radius: 4px;
        display: none;
    }

    .status-message.success {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
    }

    .status-message.error {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
    }

    .status-message.info {
        background: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
    }

    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #4CAF50;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-left: 10px;
        vertical-align: middle;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }


    .instructions {
        background: #f8f9fa;
        border-left: 4px solid #4CAF50;
        padding: 15px;
        margin-bottom: 20px;
    }

    .instructions h3 {
        margin-top: 0;
        color: #333;
    }

    .instructions ul {
        margin: 10px 0;
        padding-left: 20px;
    }

    .instructions li {
        margin-bottom: 5px;
        color: #666;
    }

    .checkbox-label {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-weight: 500;
    }

    .checkbox-label input[type="checkbox"] {
        width: auto;
        margin-right: 8px;
        cursor: pointer;
    }

    .quality-info {
        margin-top: 8px;
        font-size: 12px;
        color: #666;
        padding-left: 24px;
    }
    /* 戻るボタン */
    .back-button {
        display: inline-block;
        margin-bottom: 20px;
        padding: 8px 16px;
        background-color: #666;
        color: white;
        text-decoration: none;
        border-radius: 3px;
        transition: background-color 0.3s;
    }

    .back-button:hover {
        background-color: #555;
    }
</style>

<div class="download-container">
    <a href="/Drowse-Lab/other.html" class="back-button" data-i18n="download.back">← 戻る</a>
    
    <div class="download-header">
        <h1 data-i18n="download.title">ファイルダウンロード</h1>
        <p data-i18n="download.subtitle">URLからファイルをダウンロードします</p>
    </div>

    <div class="instructions">
        <h3 data-i18n="download.howToUse">使い方</h3>
        <ul>
            <li data-i18n="download.instruction1">ダウンロードしたいファイルのURLを入力してください</li>
            <li data-i18n="download.instruction2">ファイル名を指定できます（省略可）</li>
            <li data-i18n="download.instruction3">ダウンロードボタンをクリックしてファイルを保存します</li>
        </ul>
        <p style="margin-top: 15px; font-size: 13px; color: #666;">
            <strong data-i18n="download.tip">ヒント:</strong>
            <span data-i18n="download.tipContent">Fandom Wikiの画像は、画像を右クリックして「画像アドレスをコピー」で直接URLを取得するか、WikiページのURLをそのまま入力してください。</span>
        </p>
    </div>

    <div class="download-form">
        <div class="form-group">
            <label for="urlInput" data-i18n="download.urlLabel">ファイルURL</label>
            <input 
                type="url" 
                id="urlInput" 
                placeholder="https://example.com/file.pdf" 
                data-i18n-placeholder="download.urlPlaceholder"
                required
            >
        </div>

        <div class="form-group">
            <label for="filenameInput" data-i18n="download.filenameLabel">保存ファイル名（オプション）</label>
            <input 
                type="text" 
                id="filenameInput" 
                placeholder="file.pdf" 
                data-i18n-placeholder="download.filenamePlaceholder"
                list="extensionList"
            >
            <datalist id="extensionList">
                <option value=".jpg">
                <option value=".jpeg">
                <option value=".png">
                <option value=".gif">
                <option value=".webp">
                <option value=".bmp">
                <option value=".svg">
                <option value=".pdf">
                <option value=".txt">
                <option value=".html">
                <option value=".mp4">
                <option value=".mp3">
                <option value=".wav">
                <option value=".zip">
                <option value=".rar">
            </datalist>
        </div>

        <div class="form-group">
            <label class="checkbox-label">
                <input type="checkbox" id="enhanceQuality">
                <span data-i18n="download.enhanceQuality">画質を向上させる（画像のみ）</span>
            </label>
            <div class="quality-info" data-i18n="download.qualityInfo">
                画像をアップスケーリングして画質を改善します
            </div>
            <div id="resolutionOptions" style="display: none; margin-top: 15px;">
                <label for="resolutionSelect" style="display: block; margin-bottom: 8px; font-weight: 500;" data-i18n="download.resolution">解像度を選択:</label>
                <select id="resolutionSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="auto" data-i18n="download.resAuto">自動（最適な解像度）</option>
                    <option value="4k" data-i18n="download.res4k">4K (3840×2160)</option>
                    <option value="1440p" data-i18n="download.res1440p">1440p (2560×1440)</option>
                    <option value="1080p" data-i18n="download.res1080p">1080p (1920×1080)</option>
                    <option value="720p" data-i18n="download.res720p">720p (1280×720)</option>
                    <option value="original" data-i18n="download.resOriginal">オリジナルサイズ（画質向上のみ）</option>
                </select>
            </div>
        </div>
        
        <!-- YouTube用オプション -->
        <div id="youtubeOptions" style="display: none;">
            <div class="form-group">
                <label for="formatSelect" style="display: block; margin-bottom: 8px; font-weight: 600;" data-i18n="download.format">フォーマット:</label>
                <select id="formatSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="video" data-i18n="download.formatVideo">動画 (MP4)</option>
                    <option value="audio" data-i18n="download.formatAudio">音声のみ (MP3)</option>
                </select>
            </div>
            <div class="form-group" id="videoQualityGroup">
                <label for="videoQuality" style="display: block; margin-bottom: 8px; font-weight: 600;" data-i18n="download.videoQuality">動画品質:</label>
                <select id="videoQuality" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="highest" data-i18n="download.qualityHighest">最高品質</option>
                    <option value="1080p">1080p</option>
                    <option value="720p">720p</option>
                    <option value="480p">480p</option>
                    <option value="360p">360p</option>
                </select>
            </div>
            <div class="youtube-warning" style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 10px; margin-top: 10px;">
                <strong data-i18n="download.youtubeWarning">注意:</strong>
                <span data-i18n="download.youtubeWarningText">YouTube動画のダウンロードは利用規約に注意してください。個人利用のみで、著作権を尊重してください。</span>
            </div>
        </div>

        <button id="downloadBtn" class="download-button" data-i18n="download.downloadButton">ダウンロード</button>

        <div id="statusMessage" class="status-message"></div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const urlInput = document.getElementById('urlInput');
    const filenameInput = document.getElementById('filenameInput');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusMessage = document.getElementById('statusMessage');
    const enhanceQualityCheckbox = document.getElementById('enhanceQuality');
    const resolutionOptions = document.getElementById('resolutionOptions');
    const resolutionSelect = document.getElementById('resolutionSelect');
    const youtubeOptions = document.getElementById('youtubeOptions');
    const formatSelect = document.getElementById('formatSelect');
    const videoQualityGroup = document.getElementById('videoQualityGroup');
    const videoQuality = document.getElementById('videoQuality');
    
    // 画質向上チェックボックスの変更イベント
    enhanceQualityCheckbox.addEventListener('change', function() {
        resolutionOptions.style.display = this.checked ? 'block' : 'none';
    });
    
    // フォーマット選択の変更イベント
    formatSelect.addEventListener('change', function() {
        videoQualityGroup.style.display = this.value === 'video' ? 'block' : 'none';
    });
    
    // URL入力の変更イベント（YouTube検出）
    urlInput.addEventListener('input', function() {
        const url = this.value;
        const isYouTube = isYouTubeUrl(url);
        
        if (isYouTube) {
            youtubeOptions.style.display = 'block';
            enhanceQualityCheckbox.parentElement.parentElement.style.display = 'none';
        } else {
            youtubeOptions.style.display = 'none';
            enhanceQualityCheckbox.parentElement.parentElement.style.display = 'block';
        }
    });
    
    // ファイル名入力で拡張子候補を動的に更新
    filenameInput.addEventListener('input', function() {
        const value = this.value;
        const lastDot = value.lastIndexOf('.');
        if (lastDot > -1) {
            const base = value.substring(0, lastDot);
            const datalist = document.getElementById('extensionList');
            
            // オプションを更新して、現在のファイル名に拡張子を追加
            Array.from(datalist.options).forEach(option => {
                option.value = base + option.textContent;
            });
        }
    });
    
    function isYouTubeUrl(url) {
        return url.includes('youtube.com/watch') || 
               url.includes('youtu.be/') || 
               url.includes('youtube.com/shorts/');
    }
    
    function extractYouTubeId(url) {
        const patterns = [
            /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/shorts\/)([^&\n?#]+)/,
        ];
        
        for (const pattern of patterns) {
            const match = url.match(pattern);
            if (match) return match[1];
        }
        return null;
    }

    function showStatus(message, type) {
        statusMessage.textContent = message;
        statusMessage.className = `status-message ${type}`;
        statusMessage.style.display = 'block';
    }

    function hideStatus() {
        statusMessage.style.display = 'none';
    }

    function extractFilenameFromUrl(url, mimeType) {
        try {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            let filename = pathname.split('/').pop();
            
            // クエリパラメータを除去
            if (filename) {
                filename = filename.split('?')[0];
            }
            
            // URLパラメータやクエリから元のファイル名を取得（Fandomなどのサイト用）
            const fileParam = urlObj.searchParams.get('file');
            if (fileParam) {
                filename = fileParam.split('/').pop();
            }
            
            // URLパラメータにformat,webpが含まれているかチェック
            const hasWebPFormat = url.includes('format,webp') || url.includes('format=webp');
            
            // 元がGIFかどうか判定
            const isOriginallyGif = (filename && filename.toLowerCase().includes('.gif')) ||
                                   url.includes('gif') ||
                                   (fileParam && fileParam.toLowerCase().includes('.gif'));
            
            // URLにファイル名が含まれていない場合、またはファイル名に拡張子がない場合
            if (!filename || filename === '' || !filename.includes('.')) {
                // MIMEタイプから拡張子を決定
                const extension = getExtensionFromMimeType(mimeType);
                if (!filename || filename === '') {
                    filename = 'download' + extension;
                } else {
                    filename = filename + extension;
                }
            } else {
                // WebPに変換されている場合の処理
                if (hasWebPFormat || mimeType === 'image/webp') {
                    const lastDotIndex = filename.lastIndexOf('.');
                    if (lastDotIndex !== -1) {
                        const nameWithoutExt = filename.substring(0, lastDotIndex);
                        
                        // 元がGIFならGIFとして保存
                        if (isOriginallyGif) {
                            filename = nameWithoutExt + '.gif';
                        } else {
                            // GIF以外はJPGに変換
                            filename = nameWithoutExt + '.jpg';
                        }
                    }
                } else {
                    // 画像ファイルの拡張子を適切に変更
                    filename = adjustImageExtension(filename, mimeType);
                }
            }
            
            return filename;
        } catch (e) {
            return 'download';
        }
    }

    function getExtensionFromMimeType(mimeType) {
        if (!mimeType) return '';
        
        const mimeToExt = {
            'image/jpeg': '.jpg',
            'image/jpg': '.jpg',
            'image/png': '.png',
            'image/gif': '.gif',
            'image/webp': '.jpg', // WebPはJPGに変換
            'image/bmp': '.bmp',
            'image/svg+xml': '.svg',
            'image/x-icon': '.ico',
            'image/tiff': '.tiff',
            'text/plain': '.txt',
            'text/html': '.html',
            'application/json': '.json',
            'application/xml': '.xml',
            'application/zip': '.zip',
            'application/x-rar-compressed': '.rar',
            'application/x-7z-compressed': '.7z',
            'video/mp4': '.mp4',
            'video/webm': '.webm',
            'audio/mpeg': '.mp3',
            'audio/wav': '.wav'
        };
        
        return mimeToExt[mimeType] || '';
    }

    function adjustImageExtension(filename, mimeType) {
        if (!mimeType || !mimeType.startsWith('image/')) {
            return filename;
        }
        
        // 現在の拡張子を取得
        const lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex === -1) {
            return filename + getExtensionFromMimeType(mimeType);
        }
        
        const nameWithoutExt = filename.substring(0, lastDotIndex);
        const currentExt = filename.substring(lastDotIndex).toLowerCase();
        
        // WebP、AVIF、その他の形式をJPGに変換
        if (currentExt === '.webp' || currentExt === '.avif' || currentExt === '.jfif') {
            return nameWithoutExt + '.jpg';
        }
        
        // GIFはそのまま保持
        if (currentExt === '.gif') {
            return filename;
        }
        
        // PNGとJPG/JPEGは適切に保持
        if (currentExt === '.png' || currentExt === '.jpg' || currentExt === '.jpeg') {
            return filename;
        }
        
        // その他の画像形式はMIMEタイプに基づいて決定
        return nameWithoutExt + getExtensionFromMimeType(mimeType);
    }

    async function convertImageBlob(blob, targetFormat, enhanceQuality = false) {
        return new Promise((resolve) => {
            const img = new Image();
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            img.onload = function() {
                let width = img.width;
                let height = img.height;
                
                // 画質向上モード：解像度を上げる
                if (enhanceQuality) {
                    // 元のサイズが小さい場合は2倍または4倍にアップスケール
                    const scaleFactor = (width < 500 || height < 500) ? 4 : 2;
                    width *= scaleFactor;
                    height *= scaleFactor;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                // 画質向上のための設定
                if (enhanceQuality) {
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // シャープネスフィルターの適用
                    ctx.filter = 'contrast(1.1) saturate(1.1)';
                }
                
                ctx.drawImage(img, 0, 0, width, height);
                
                // 画質を最高にして保存
                const quality = enhanceQuality ? 1.0 : 0.95;
                
                canvas.toBlob(function(newBlob) {
                    resolve(newBlob);
                }, targetFormat, quality);
            };
            
            img.src = URL.createObjectURL(blob);
        });
    }

    async function enhanceImageQuality(blob, targetResolution = 'auto') {
        return new Promise((resolve) => {
            const img = new Image();
            
            img.onload = function() {
                // 元画像のサイズ
                const originalWidth = img.width;
                const originalHeight = img.height;
                const aspectRatio = originalWidth / originalHeight;
                
                let width, height;
                
                // 解像度設定に基づいて目標サイズを決定
                switch(targetResolution) {
                    case '4k':
                        // 4K: 3840×2160 (16:9) または相当
                        if (aspectRatio > 16/9) {
                            width = 3840;
                            height = Math.round(3840 / aspectRatio);
                        } else {
                            height = 2160;
                            width = Math.round(2160 * aspectRatio);
                        }
                        break;
                    case '1440p':
                        // 1440p: 2560×1440 (16:9) または相当
                        if (aspectRatio > 16/9) {
                            width = 2560;
                            height = Math.round(2560 / aspectRatio);
                        } else {
                            height = 1440;
                            width = Math.round(1440 * aspectRatio);
                        }
                        break;
                    case '1080p':
                        // 1080p: 1920×1080 (16:9) または相当
                        if (aspectRatio > 16/9) {
                            width = 1920;
                            height = Math.round(1920 / aspectRatio);
                        } else {
                            height = 1080;
                            width = Math.round(1080 * aspectRatio);
                        }
                        break;
                    case '720p':
                        // 720p: 1280×720 (16:9) または相当
                        if (aspectRatio > 16/9) {
                            width = 1280;
                            height = Math.round(1280 / aspectRatio);
                        } else {
                            height = 720;
                            width = Math.round(720 * aspectRatio);
                        }
                        break;
                    case 'original':
                        // オリジナルサイズを維持（画質向上のみ）
                        width = originalWidth;
                        height = originalHeight;
                        break;
                    case 'auto':
                    default:
                        // 自動：最適な倍率を決定
                        let scaleFactor = 2;
                        if (originalWidth < 400 || originalHeight < 400) {
                            scaleFactor = 4;
                        } else if (originalWidth < 800 || originalHeight < 800) {
                            scaleFactor = 3;
                        } else if (originalWidth > 1500 || originalHeight > 1500) {
                            scaleFactor = 1.5;
                        }
                        width = Math.round(originalWidth * scaleFactor);
                        height = Math.round(originalHeight * scaleFactor);
                        
                        // 最大4Kまでに制限
                        if (width > 3840) {
                            const scale = 3840 / width;
                            width = 3840;
                            height = Math.round(height * scale);
                        }
                        if (height > 2160) {
                            const scale = 2160 / height;
                            height = 2160;
                            width = Math.round(width * scale);
                        }
                        break;
                }
                
                // 元画像より小さくしない（originalモード以外）
                if (targetResolution !== 'original') {
                    if (width < originalWidth) width = originalWidth;
                    if (height < originalHeight) height = originalHeight;
                }
                
                // 複数のキャンバスを使用して段階的に処理
                const canvas1 = document.createElement('canvas');
                const ctx1 = canvas1.getContext('2d');
                
                // ステップ1: 高品質アップスケーリング
                canvas1.width = width;
                canvas1.height = height;
                
                // アンチエイリアシング有効化
                ctx1.imageSmoothingEnabled = true;
                ctx1.imageSmoothingQuality = 'high';
                
                // バイキュービック補間を模倣
                ctx1.drawImage(img, 0, 0, width, height);
                
                // ステップ2: シャープネス処理
                const canvas2 = document.createElement('canvas');
                const ctx2 = canvas2.getContext('2d');
                canvas2.width = width;
                canvas2.height = height;
                
                // シャープネスフィルター適用
                ctx2.filter = 'contrast(1.1) saturate(1.05) brightness(1.02)';
                ctx2.drawImage(canvas1, 0, 0);
                
                // ステップ3: アンシャープマスク処理
                const imageData = ctx2.getImageData(0, 0, width, height);
                const data = imageData.data;
                const origData = new Uint8ClampedArray(data);
                
                // エッジ検出と強調（簡易アンシャープマスク）
                const radius = 1;
                const strength = 0.5;
                
                for (let y = radius; y < height - radius; y++) {
                    for (let x = radius; x < width - radius; x++) {
                        const idx = (y * width + x) * 4;
                        
                        for (let c = 0; c < 3; c++) {
                            let sum = 0;
                            let count = 0;
                            
                            // 周囲のピクセルの平均を計算
                            for (let dy = -radius; dy <= radius; dy++) {
                                for (let dx = -radius; dx <= radius; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nIdx = ((y + dy) * width + (x + dx)) * 4 + c;
                                    sum += origData[nIdx];
                                    count++;
                                }
                            }
                            
                            const avg = sum / count;
                            const diff = origData[idx + c] - avg;
                            
                            // エッジを強調
                            data[idx + c] = Math.min(255, Math.max(0, 
                                origData[idx + c] + diff * strength
                            ));
                        }
                    }
                }
                
                ctx2.putImageData(imageData, 0, 0);
                
                // ステップ4: ノイズリダクション（オプション）
                const canvas3 = document.createElement('canvas');
                const ctx3 = canvas3.getContext('2d');
                canvas3.width = width;
                canvas3.height = height;
                
                // 軽微なブラーをかけてからシャープネスを再適用
                ctx3.filter = 'blur(0.3px)';
                ctx3.drawImage(canvas2, 0, 0);
                
                // 最終的なシャープネス調整
                const finalCanvas = document.createElement('canvas');
                const finalCtx = finalCanvas.getContext('2d');
                finalCanvas.width = width;
                finalCanvas.height = height;
                
                finalCtx.filter = 'contrast(1.05) saturate(1.02)';
                finalCtx.drawImage(canvas3, 0, 0);
                
                // 高画質で保存（PNG/JPEGを判定）
                const outputFormat = blob.type === 'image/png' ? 'image/png' : 'image/jpeg';
                const quality = outputFormat === 'image/jpeg' ? 0.98 : 1.0;
                
                finalCanvas.toBlob(function(newBlob) {
                    console.log(`Image enhanced: ${originalWidth}x${originalHeight} → ${width}x${height}`);
                    resolve(newBlob);
                }, outputFormat, quality);
            };
            
            img.src = URL.createObjectURL(blob);
        });
    }

    async function convertToGif(blob) {
        // WebPアニメーションからGIFへの変換は複雑なため、
        // 静止画として保存するか、元のWebPをGIFとして保存
        // ブラウザの制限により、完全なアニメーション変換は困難
        return blob;
    }

    // FandomのようなWikiサイトから実際の画像URLを取得
    async function extractActualImageUrl(url) {
        // FandomのWikiページの場合
        if (url.includes('fandom.com') && url.includes('wiki')) {
            try {
                showStatus('Wikiページから画像を取得しています...', 'info');
                
                // URLからファイル名を抽出
                const urlObj = new URL(url);
                const fileParam = urlObj.searchParams.get('file');
                
                if (fileParam) {
                    // Wikiページをフェッチして実際の画像URLを探す
                    try {
                        // CORSプロキシ経由でページを取得
                        const pageUrl = url.split('?')[0]; // クエリパラメータを除去
                        const proxyPageUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
                        
                        const pageResponse = await fetch(proxyPageUrl);
                        if (pageResponse.ok) {
                            const pageText = await pageResponse.text();
                            
                            // 画像URLを正規表現で探す
                            // パターン1: static.wikia.nocookie.net のURL
                            const imgUrlPattern = /https:\/\/static\.wikia\.nocookie\.net\/[^"'\s]+\.gif/gi;
                            const matches = pageText.match(imgUrlPattern);
                            
                            if (matches && matches.length > 0) {
                                // ファイル名に一致する画像URLを探す
                                const targetFilename = fileParam.toLowerCase();
                                for (const match of matches) {
                                    if (match.toLowerCase().includes(targetFilename.replace(/_/g, ''))) {
                                        console.log('Found actual image URL:', match);
                                        // /revision/latest を削除してオリジナル画像を取得
                                        const cleanUrl = match.split('/revision/')[0];
                                        return cleanUrl;
                                    }
                                }
                                
                                // 一致するものが見つからない場合は最初のGIFを使用
                                console.log('Using first GIF found:', matches[0]);
                                return matches[0].split('/revision/')[0];
                            }
                        }
                    } catch (e) {
                        console.log('Failed to fetch Wiki page:', e);
                    }
                    
                    // フォールバック: 直接URLを推測
                    showStatus('画像URLを推測しています...', 'info');
                    
                    // 実際のMinecraft WikiのGIF URLの例:
                    // https://static.wikia.nocookie.net/minecraft_gamepedia/images/e/ed/Enchanted_Stone_Sword.gif
                    const wikiName = url.match(/https?:\/\/([^.]+)\.fandom\.com/)?.[1] || 'minecraft';
                    
                    // よく使われるハッシュパターン
                    const hashes = ['e/ed', 'a/ab', '1/1a', '2/2b', '3/3c', '4/4d', '5/5e', '6/6f', '7/7a', '8/8b', '9/9c', '0/0a', 'b/bc', 'c/cd', 'd/de', 'f/fa'];
                    
                    for (const hash of hashes) {
                        const testUrl = `https://static.wikia.nocookie.net/${wikiName}_gamepedia/images/${hash}/${fileParam}`;
                        console.log('Trying URL pattern:', testUrl);
                        
                        // URLが有効か確認
                        try {
                            const testResponse = await fetch('https://corsproxy.io/?' + encodeURIComponent(testUrl), {
                                method: 'HEAD'
                            });
                            if (testResponse.ok) {
                                console.log('Found working URL:', testUrl);
                                return testUrl;
                            }
                        } catch (e) {
                            // 次のパターンを試す
                        }
                    }
                }
            } catch (e) {
                console.log('Failed to extract Fandom image URL:', e);
            }
        }
        
        // 他の画像直接URLの場合はそのまま返す
        if (url.includes('static.wikia.nocookie.net') || 
            url.includes('.gif') || 
            url.includes('.jpg') || 
            url.includes('.png') ||
            url.includes('.webp')) {
            return url;
        }
        
        return url;
    }

    async function getYouTubeVideoInfo(videoId) {
        try {
            // YouTube Player APIを使用して動画情報を取得
            const infoUrl = `https://www.youtube.com/get_video_info?video_id=${videoId}&el=embedded&ps=default&eurl=&hl=en`;
            
            // CORSプロキシ経由で取得
            const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(infoUrl);
            const response = await fetch(proxyUrl);
            const text = await response.text();
            
            // URLパラメータをパース
            const params = new URLSearchParams(text);
            const playerResponse = params.get('player_response');
            
            if (playerResponse) {
                return JSON.parse(playerResponse);
            }
            
            // 代替方法: YouTube oEmbed API
            const oembedUrl = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
            const oembedResponse = await fetch('https://corsproxy.io/?' + encodeURIComponent(oembedUrl));
            const oembedData = await oembedResponse.json();
            
            return {
                videoDetails: {
                    title: oembedData.title,
                    author: oembedData.author_name,
                    videoId: videoId
                }
            };
        } catch (error) {
            console.error('Failed to get video info:', error);
            return null;
        }
    }
    
    async function getYouTubeStreams(videoId) {
        try {
            // YouTube動画ページから直接ストリーム情報を取得
            const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`;
            const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(videoPageUrl);
            
            showStatus('動画情報を解析中...', 'info');
            const response = await fetch(proxyUrl);
            const html = await response.text();
            
            // ytInitialPlayerResponseを探す
            const ytConfigMatch = html.match(/ytInitialPlayerResponse\s*=\s*({.+?});/);
            if (ytConfigMatch) {
                const playerResponse = JSON.parse(ytConfigMatch[1]);
                
                if (playerResponse.streamingData) {
                    const formats = [
                        ...(playerResponse.streamingData.formats || []),
                        ...(playerResponse.streamingData.adaptiveFormats || [])
                    ];
                    
                    return formats.map(format => ({
                        itag: format.itag,
                        url: format.url || format.signatureCipher,
                        mimeType: format.mimeType,
                        quality: format.quality,
                        qualityLabel: format.qualityLabel,
                        hasAudio: format.audioQuality ? true : false,
                        hasVideo: format.width ? true : false,
                        width: format.width,
                        height: format.height,
                        contentLength: format.contentLength,
                        audioQuality: format.audioQuality
                    }));
                }
            }
            
            return [];
        } catch (error) {
            console.error('Failed to get streams:', error);
            return [];
        }
    }
    
    async function downloadYouTubeVideo(url, format, quality) {
        const videoId = extractYouTubeId(url);
        if (!videoId) {
            throw new Error('無効なYouTube URLです');
        }
        
        showStatus('YouTube動画情報を取得中...', 'info');
        
        try {
            // 動画情報を取得
            const videoInfo = await getYouTubeVideoInfo(videoId);
            const streams = await getYouTubeStreams(videoId);
            
            if (!streams || streams.length === 0) {
                throw new Error('動画ストリームが見つかりません');
            }
            
            // フォーマットに応じてストリームを選択
            let selectedStream = null;
            
            if (format === 'audio') {
                // 音声のみ - 最高品質のオーディオストリームを選択
                const audioStreams = streams.filter(s => s.hasAudio && !s.hasVideo);
                selectedStream = audioStreams.find(s => s.audioQuality === 'AUDIO_QUALITY_HIGH') ||
                                audioStreams.find(s => s.audioQuality === 'AUDIO_QUALITY_MEDIUM') ||
                                audioStreams[0];
            } else {
                // 動画 - 指定された品質のストリームを選択
                const videoStreams = streams.filter(s => s.hasVideo && s.hasAudio);
                
                if (quality === 'highest') {
                    selectedStream = videoStreams.sort((a, b) => (b.height || 0) - (a.height || 0))[0];
                } else {
                    const targetHeight = parseInt(quality.replace('p', ''));
                    selectedStream = videoStreams.find(s => s.height === targetHeight) ||
                                   videoStreams.find(s => s.height <= targetHeight) ||
                                   videoStreams[0];
                }
            }
            
            if (!selectedStream || !selectedStream.url) {
                // ストリームが暗号化されている場合、直接ダウンロードは困難
                showStatus('動画の直接ダウンロードができません。代替方法を使用します...', 'info');
                
                // 代替方法: cobalt.toolsを使用
                const cobaltUrl = `https://cobalt.tools/api/json`;
                const cobaltRequest = {
                    url: `https://www.youtube.com/watch?v=${videoId}`,
                    vQuality: quality === 'highest' ? 'max' : quality,
                    aFormat: format === 'audio' ? 'mp3' : 'best',
                    isAudioOnly: format === 'audio',
                    disableMetadata: false
                };
                
                try {
                    const cobaltResponse = await fetch('https://corsproxy.io/?' + encodeURIComponent(cobaltUrl), {
                        method: 'POST',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(cobaltRequest)
                    });
                    
                    const cobaltData = await cobaltResponse.json();
                    
                    if (cobaltData.url) {
                        // ダウンロードリンクを開く
                        window.open(cobaltData.url, '_blank');
                        showStatus('ダウンロードリンクを新しいタブで開きました', 'success');
                        return;
                    }
                } catch (cobaltError) {
                    console.error('Cobalt API failed:', cobaltError);
                }
                
                // 最終手段: ユーザーに手動ダウンロードを促す
                const manualUrl = `https://www.y2mate.com/youtube/${videoId}`;
                window.open(manualUrl, '_blank');
                throw new Error('自動ダウンロードができませんでした。開いたページから手動でダウンロードしてください。');
            }
            
            // ストリームURLが取得できた場合
            showStatus('ダウンロードを開始します...', 'info');
            
            // ファイル名を生成
            const title = videoInfo?.videoDetails?.title || `youtube_${videoId}`;
            const extension = format === 'audio' ? 'mp3' : 'mp4';
            const fileName = `${title.replace(/[^\w\s]/gi, '')}.${extension}`;
            
            // ダウンロードリンクを作成
            const downloadLink = document.createElement('a');
            downloadLink.href = selectedStream.url;
            downloadLink.download = fileName;
            downloadLink.target = '_blank';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            showStatus('ダウンロードが開始されました', 'success');
            
        } catch (error) {
            console.error('YouTube download error:', error);
            showStatus(`エラー: ${error.message}`, 'error');
            
            // エラー時は外部サービスにフォールバック
            const fallbackUrl = format === 'audio' 
                ? `https://www.y2mate.com/youtube/${videoId}`
                : `https://cobalt.tools/`;
            
            window.open(fallbackUrl, '_blank');
            throw new Error('自動ダウンロードに失敗しました。開いたページをご利用ください。');
        }
    }
    
    async function downloadFile(url, filename) {
        try {
            downloadBtn.disabled = true;
            downloadBtn.innerHTML = `<span data-i18n="download.downloading">ダウンロード中</span><span class="loading"></span>`;
            
            // YouTubeの場合
            if (isYouTubeUrl(url)) {
                const format = formatSelect.value;
                const quality = videoQuality.value;
                await downloadYouTubeVideo(url, format, quality);
                return;
            }
            
            // FandomのようなWikiサイトの場合、実際の画像URLを取得
            const actualUrl = await extractActualImageUrl(url);
            if (actualUrl !== url) {
                console.log('Using actual image URL:', actualUrl);
                url = actualUrl;
            }
            
            // まずHEADリクエストでMIMEタイプを確認
            let mimeType = null;
            try {
                const headResponse = await fetch(url, {
                    method: 'HEAD',
                    mode: 'cors',
                    credentials: 'omit'
                });
                mimeType = headResponse.headers.get('content-type');
            } catch (e) {
                console.log('HEAD request failed, continuing with GET');
            }
            
            const response = await fetch(url, {
                mode: 'cors',
                credentials: 'omit'
            }).catch(async (error) => {
                // CORS エラーの場合、プロキシ経由で試す
                console.log('Direct fetch failed, trying proxy method');
                
                // CORSプロキシを使用（公開プロキシサービス）
                const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
                try {
                    const proxyResponse = await fetch(proxyUrl);
                    if (proxyResponse.ok) {
                        return proxyResponse;
                    }
                } catch (proxyError) {
                    console.log('Proxy also failed');
                }
                
                // WikiページのURLの場合、直接画像を開くリンクを提供
                if (url.includes('wiki') && (url.includes('file=') || url.includes('File:'))) {
                    showStatus('Wikiページです。画像を直接開くには、ページ内の画像を右クリックして「画像を新しいタブで開く」を選択し、その画像URLをここに貼り付けてください。', 'info');
                    throw new Error('Wikiページから直接ダウンロードできません。画像の直接URLが必要です。');
                }
                
                // 最終手段: 新しいタブで開く
                const link = document.createElement('a');
                link.href = url;
                link.download = filename || 'download';
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                throw new Error('CORS制限により直接ダウンロードできません。新しいタブで開きます。');
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            let blob = await response.blob();
            if (!mimeType) {
                mimeType = blob.type;
            }
            
            // 画像の形式変換処理
            if (mimeType && mimeType.startsWith('image/')) {
                const urlPath = new URL(url).pathname.toLowerCase();
                const originalFilename = urlPath.split('/').pop() || '';
                const shouldEnhance = enhanceQualityCheckbox.checked;
                
                // URLやファイル名から元の形式を判定
                const isOriginallyGif = originalFilename.includes('.gif') || 
                                       url.includes('gif') || 
                                       url.includes('file=') && url.includes('.gif');
                
                // 画質向上処理（GIF以外の画像）
                if (shouldEnhance && !isOriginallyGif) {
                    const selectedResolution = resolutionSelect.value;
                    const originalSize = blob.size;
                    const resText = selectedResolution === 'auto' ? '自動' : selectedResolution.toUpperCase();
                    showStatus(`画質を向上させています... (${resText}にアップスケーリング中)`, 'info');
                    blob = await enhanceImageQuality(blob, selectedResolution);
                    const newSize = blob.size;
                    console.log(`File size: ${(originalSize/1024).toFixed(1)}KB → ${(newSize/1024).toFixed(1)}KB`);
                }
                
                // WebPやAVIFの処理
                if (mimeType === 'image/webp' || mimeType === 'image/avif') {
                    if (isOriginallyGif) {
                        // 元がGIFの場合はGIFとして保存（アニメーション保持のため変換しない）
                        showStatus('GIFファイルを処理中...', 'info');
                        // ファイル名の拡張子だけ.gifに変更
                        mimeType = 'image/gif';
                    } else {
                        // GIF以外はJPEGに変換
                        if (!shouldEnhance) {
                            showStatus('画像を変換中...', 'info');
                        }
                        blob = await convertImageBlob(blob, 'image/jpeg', shouldEnhance);
                        mimeType = 'image/jpeg';
                    }
                }
                // URLパラメータでWebP変換されている場合も処理
                else if (url.includes('format,webp') || url.includes('format=webp')) {
                    if (isOriginallyGif) {
                        // 元がGIFの場合はGIFとして扱う
                        showStatus('GIFファイルを処理中...', 'info');
                        mimeType = 'image/gif';
                    } else {
                        // GIF以外はJPEGに変換
                        if (!shouldEnhance) {
                            showStatus('画像を変換中...', 'info');
                        }
                        blob = await convertImageBlob(blob, 'image/jpeg', shouldEnhance);
                        mimeType = 'image/jpeg';
                    }
                }
                // 通常の画像で画質向上のみ行う場合
                else if (shouldEnhance && !isOriginallyGif) {
                    // 既に画質向上処理済み
                }
            }
            
            const downloadUrl = window.URL.createObjectURL(blob);
            
            // ファイル名の決定
            const finalFilename = filename || extractFilenameFromUrl(url, mimeType);
            
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = finalFilename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up
            setTimeout(() => {
                window.URL.revokeObjectURL(downloadUrl);
            }, 100);
            
            showStatus(`ダウンロードが完了しました: ${finalFilename}`, 'success');
        } catch (error) {
            console.error('Download error:', error);
            
            if (error.message.includes('CORS')) {
                showStatus(error.message, 'info');
            } else {
                showStatus(`エラー: ${error.message}`, 'error');
            }
        } finally {
            downloadBtn.disabled = false;
            downloadBtn.innerHTML = '<span data-i18n="download.downloadButton">ダウンロード</span>';
        }
    }

    downloadBtn.addEventListener('click', async function() {
        const url = urlInput.value.trim();
        const filename = filenameInput.value.trim();
        
        if (!url) {
            showStatus('URLを入力してください', 'error');
            return;
        }
        
        // URL検証
        try {
            new URL(url);
        } catch (e) {
            showStatus('有効なURLを入力してください', 'error');
            return;
        }
        
        hideStatus();
        await downloadFile(url, filename);
    });

    // Enterキーでダウンロード
    urlInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            downloadBtn.click();
        }
    });
    
    filenameInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            downloadBtn.click();
        }
    });
});

// 国際化対応 - JSONファイルから翻訳を読み込み
let translations = {};

async function loadTranslations() {
    try {
        const response = await fetch('/Drowse-Lab/assets/data/translations.json');
        translations = await response.json();
        
        // 言語切り替え機能との統合
        if (typeof window.loadLanguage === 'function') {
            window.loadLanguage();
        }
        
        // 初期言語を適用
        applyTranslations();
    } catch (error) {
        console.error('Failed to load translations:', error);
    }
}

function applyTranslations() {
    const lang = localStorage.getItem('selectedLanguage') || 'ja';
    const trans = translations[lang] || translations['ja'];
    
    // data-i18n属性を持つ要素を更新
    document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (trans[key]) {
            element.textContent = trans[key];
        }
    });
    
    // placeholder属性を更新
    document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
        const key = element.getAttribute('data-i18n-placeholder');
        if (trans[key]) {
            element.placeholder = trans[key];
        }
    });
}

// ページ読み込み時に翻訳を読み込む
loadTranslations();

// 言語切り替えボタンのイベントリスナー
document.addEventListener('DOMContentLoaded', function() {
    const langToggleBtn = document.getElementById('langToggleBottom');
    if (langToggleBtn) {
        langToggleBtn.addEventListener('click', function() {
            const currentLang = localStorage.getItem('selectedLanguage') || 'ja';
            const newLang = currentLang === 'ja' ? 'en' : 'ja';
            localStorage.setItem('selectedLanguage', newLang);
            applyTranslations();
        });
    }
});
</script>